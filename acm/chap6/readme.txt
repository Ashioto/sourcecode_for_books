UV679 小球下落
可以模拟小球下落的整个过程，利用k，2k，2k+1的性质，注意根结点的标号为1
也可以通过奇偶性来进行，大大缩短时间，也利用了某种“递归”的想法，对于每层来说都是一样的。

UVa122 树的层次遍历
主要使用了数组来构造二叉树，bfs。
Left Right values  （left，right在c++中已被使用）
定义了failed变量，new tree，new node使用cnt来分配。
使用数组而不是指针的好处主要是便于调试，同时移植到其他语言中也比较方便。

UVa548 树
dfs
主要还是build函数的参数形式比较重要

UVa839 天平
使用了带引用的递归
因为每层函数需要传递的信息有：总重量，左右两端是否平衡
注意两个bool的默认值，已在文件中用key point标出。

UVa699 下落的树叶
递归题，有一些细节需要考虑。
一个是每次调用函数的时候要不要cin，一个是if为真的时候才递归还是在递归函数的最开始用return把不符合条件的
调用return掉。
有个小细节就是第一个数字的读取后判断是否为0然后手动两次递归调用了。

UVa297 四分树
属于if为真的时候进行递归
另外递归函数的类型也很重要，之前有一道题因为把树建立好之后需要调用bfs，所以建树建的很完整。
而在这道题目中只需要跑遍所有的结点就可以了，用void就行。
这题的递归函数形式的设计要想到
draw(int r, int c, int w)
draw(r, c+w/2, w/2);
draw(r, c    , w/2); 。。。

UVa572 油田
用dfs找同色块的题，没有下面的那道难
floodfill 种子填充
dfs的函数形式，一般有个dfs(r, c, ++cnt);
在dfs中继续递归的条件一般有3个左右，在格子内、没有走过（下面的那道题目还要考虑不同方向的）、是同类的

UVa816 Abbott的复仇  **important**
这道题很重要，而且错了两个地方，改了挺久。
第一个地方是walk函数，左转、右转是加1还是加3是不同的。
第二个地方是print_ans函数，这个函数里也有两个地方，第一个是break的地方，我一开始break的地方弄错了，
导致有一个结点没有放到vector里去，还有一个地方是什么是判断break的条件。
我之前想的回到r1，c1就可以了，但是实际上不是。本题中可能先走了一个环还回到了r1，c1的地方只为了转个方向，
因此d矩阵是很有必要的。关于d矩阵也有些小的注意点，一个是初始化为-1，一个是0值别忘了，还有一个就是不同dir时候的
d是不同的，就算在地图的同一个点上。
总之，很有技巧而且细节很重要的题目。
